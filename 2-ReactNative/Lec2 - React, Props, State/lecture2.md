# CS50M -Lecture2 React, Props, State

## Classes
- ES6で導入された構文
- 複雑なプロトタイプ宣言によるオブジェクトの定義をわかりやすくする

クラス構文を導入すると、2つの新たな概念が生まれる
  - [クラス](#クラス)Classes
  - [インスタンス](#インスタンス)Instances


### クラス
プロトタイプ関数メソッドとして持つことができるES6で導入された糖衣構文
インスタンス化すると使用できるメソッドと、インスタンス化しなくても使用できる静的メソッド、値を持つプロパティをもつ。


### メソッドの種類
  - [Methods:メソッド](#メソッド)
  - [Static Methods:静的メソッド](#静的メソッド)
  - [Properties:プロパティ](#プロパティ)


#### メソッド
クラスをインスタンス化したときに呼び出すことができるメソッド
```Javascript
const d = new Date()
```
- このように`new`演算子でインスタンス化したときに使用できる


#### 静的メソッド
クラスをインスタンス化しなくても使用できる関数
- `Date.now()`や`Math.sin()`のようにクラスとメソッドを記すだけで使用できる


#### プロパティ
関数ではなく値としてクラスに付随する値
クラス外で呼び出す際は[getter, setter](#Get,Set)を使用することが多い。

#### コンストラクター
- コンストラクターはクラス内で定義され、new演算子を使用してクラスをインスタンス化した際、引数によって与えられる値を指定するための特別なメソッド
```Javascript
class Set {
  constructor (arr) { // コンストラクタ
    this.arr = arr
  }

  add(val) {
    if (!this.has(val)) this.arr.push(val)
  }

  delete(val) {
    this.arr = this.arr.filter(x =>  !== val)
  }

  has(val) {
    return this.arr.includes(val)
  }

  get size () {
    return this.arr.length
  }
}
```
この例で言うthisはオブジェクトのインスタンスに対する参照です。


#### Get,Set
クラス外からプロパティにアクセスするためのメソッドを提供します
この接頭語をつけることで直接値を参照できます。
classの例で作成されていた`size`メソッドの使用例です
```Javascript
const s = Set([1, 2, 3, 4])
console.log(s.size)
```
メソッドのように`()`をつけることなく値に参照することができています。


#### Extends, Super
`extends`は既存のクラスの機能を継承した新しいクラスを宣言することができる。

`super`は`extends`したクラスで、継承元のコンストラクターをそのまま使用することを可能にする特別な関数。
```JavaScript
class AnyClasss {
  constructor(props) {
    this.props = props;
  }
}
class App extends AnyClasss {
  constructor(props) {
    super(props)
  }
}
```


### new演算子
クラスをインスタンス化し、その時引数に値を入力することでコンストラクターに対し値を渡し、その値をインスタンス化したクラス内で使用することができる。
```Javascript
const d = new Date(1234)
'Thu Jan 01 1970 09:00:01 GMT+0900 (GMT+09:00)'
```
- 1234を渡したので、1秒234msがDataクラス内で使用されている。


## React
- データの変更に自動的に反応する宣言的なビューを作成するJavaScriptライブラリ
- 複雑な問題をより小さなコンポーネントに分けることで抽象化します。
- そして、コンポーネントを実行する単純なコードを書くことでビューを作成できます。

CS50では命令型プログラミングというパラダイムでプログラムを学びました。
今回は宣言型コーディングについて学びます。


### 命令型と宣言型の違い
命令型はプログラムが望む命令へ到達するためにいくつものステップを踏みますが、宣言型はプログラムが望む命令を宣言するだけでその命令に到達します。

HTMLは宣言型言語としてみなされている

ここにギターがある
このギターについて命令的な方法で説明するにはどのように説明するか
1. ヘッドが必要なのでヘッドを追加する
2. ペグが必要なのでペグを追加する
3. ネックが必要なのでネックを追加する
4. ネックにはフレットが必要なのでフレットを追加する
5. ...
6. ボディを作成しそれらに要素をすべて取り付けて返す

宣言的な方法で説明するとこうなる
ギターがほしい
ほしいギターの設定に対し、味付けをしていく

命令型ではそれぞれの要素を作り出しながらそれを出力するのに対し、宣言型では先に出力される形を宣言しておいてから状態を与えます。

また、ふたつのぷろぐらみんぐぱらだいむのおおきなちがいとして、ループ処理の違いがあります。
命令型ではforループを使用して変数そのものを参照していくの日亜市、宣言画では関数を再帰的に呼び出すことにより変数に対し値を適用します。

### コンポーネント化
Reactが優れている点として宣言的であるということがわかりましたが、もう1つの優れた点として容易にコンポーネント化できるという事が挙げられます。

コンポーネント化はその名の通り細かいコンポーネントをいくつも作ることです。

複雑な処理をする際、コンポーネント化されていないプログラムはバグが起きた際、どこに問題があるのか追跡するのにとてもコストが掛かります。

これがかんたんな処理であればコンポーネント化することのメリットは感じにくいかもしれませんが、より大規模な開発になっていくに連れ、コンポーネント化によるメリットは大きくなっていくでしょう。


さらに、機能を個別に分けることで似たような機能を使用しなければならなくなった際、新たに機能を追加することなく既存のコンポーネントを使用することで実装することができるようになります。

これは再利用可能性とよばれます。

コンポーネントとは言っていますが、それはただの関数の塊です


### Reactは多くの機能を備える
通常、DOMを操作する際は非常に面倒な記述をしなければなりません。
Reactはstate（状態）を管理するReconciliationというアルゴリズムを持っているため、DOMを新たに作成することなく[State](#state)を変更するだけでページが更新されます。


#### 仮想DOM
DOMを直接操作するのはパフォーマンスに悪影響を及ぼし、とくに要素を破棄したり新しい要素を作成するなどの操作は比較的時間がかかります。

Reactでは状態をメモリ上に保持することで変更があった差分のみビューを変更します。


#### JSX
JSXはJavaScript XMLの略でFacebookがReactのために開発した記法です。

React内ではJavaScriptとHTMLが混ざった気泡を使用していることに気がつくかもしれません。
これは、FacebookがReactのために開発したJavaScriptの内部でHTMLのような記法ができる言語です。

JSXはテンプレートリテラルなどではなく、ECMAScriptのデフォルト機能であるPrimaryExpressionを拡張します。
つまりパーサーとしての機能を追加します 。

誤解を恐れずに言うと、TypeScriptやCoffeScriptと同じようなトランスパイラおよび言語です。

ちなみに、JSXはXMLを冠したXMLのような見た目ですが、あくまでもXMLとの互換を目指しておらずこ親しみやすさのためにこのような記法が使用されており、XMLの機能をすべて使用できることを保証するものではありません。

[FacebookからJSXの草案記事](https://facebook.github.io/jsx/)


JSXではタグの大文字小文字で既存の要素かどうかを認識します。

小文字で記述された`<a>`や`<p>`などは通常のHTMLとして認識され、大文字で記述されたものは新たに定義されたカスタムコンポーネントとして認識されます。


#### コンポーネントは関数
コンポーネントはノードを返します。
ノードはReactがレンダーできる<div / > 文字列、数値などなどのこと

コンポーネントはプロパティのオブジェクトを受け取ります。
カスタムコンポーネントの関数名は大文字になります。
下の例では、Slideコンポーネントに対しオブジェクトを渡してレンダリングしています。
```JSX
const slideShow = (
  <div>
    {slides.map(slide => <Slide slide={slide} />)}
  </div>
)

const Slide = slide => (
  <div>
    <h1>{slide.title}</h1>
    <ul>
      {slide.bullets.map(bullet => <li>{bullet}</li>)}
    </ul>
  </div>
)
```

#### Props
オブジェクトとしてコンポーネントに渡され、返されたノードの計算に使用されます。
これらのPropsを変更すると、返されたノードの再レンダリングが行われます。
HTMLとは異なり、これらはJS上の値として使用できます。

#### State
Stateはコンポーネントが状態を保存しておけるように設定される特別なプロパティです。
React.Componentを継承したクラスでthis.stateの中に`key:value`形式で値を保存し、値を取り出したり更新できます。

`this.state`はクラス内であればどこでも参照できるのですが、値を更新するには`this.setState`というメソッドを使用しなければなりません。
